// ECUProtocol.c was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#include "PMUProtocol.hpp"

/*!
 * \brief Lookup label for 'ECUPackets' enum entry
 *
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char *PMUPackets_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case PKT_PMU_VOLTAGES:
        return translatePMU("PKT_PMU_VOLTAGES");
    case PKT_PMU_CURRENTS:
        return translatePMU("PKT_PMU_CURRENTS");
    case PKT_PMU_BATTERY_STATUSES:
        return translatePMU("PKT_PMU_BATTERY_STATUSES");
    case PKT_PMU_TEMPERATURES:
        return translatePMU("PKT_PMU_TEMPERATURES");
    case PKT_PMU_MISCELLANEOUS:
        return translatePMU("PKT_PMU_MISCELLANEOUS");
    case PKT_PMU_THROTTLE_CALIBRATION:
        return translatePMU("PKT_PMU_THROTTLE_CALIBRATION");
    case PKT_PMU_THROTTLE:
        return translatePMU("PKT_PMU_THROTTLE");
    case PKT_PMU_RPM_COMMAND:
        return translatePMU("PKT_PMU_RPM_COMMAND");
    case PKT_PMU_RPM_CALIBRATION:
        return translatePMU("PKT_PMU_RPM_CALIBRATION");
    case PKT_PMU_HARDWARE_CONFIG:
        return translatePMU("PKT_PMU_HARDWARE_CONFIG");
    case PKT_PMU_SOFTWARE_VERSION:
        return translatePMU("PKT_PMU_SOFTWARE_VERSION");
    case PKT_PMU_TPS_DELAY_CONFIG:
        return translatePMU("PKT_PMU_TPS_DELAY_CONFIG");
    case PKT_PMU_TELEMETRY_SETTINGS:
        return translatePMU("PKT_PMU_TELEMETRY_SETTINGS");
    case PKT_PMU_PUMP_CONFIG:
        return translatePMU("PKT_PMU_PUMP_CONFIG");
    case PKT_PMU_ERROR_MSG:
        return translatePMU("PKT_PMU_ERROR_MSG");
    case PKT_PMU_POWER_CYCLES:
        return translatePMU("PKT_PMU_POWER_CYCLES");
    case PKT_PMU_PUMP_2_CONFIG:
        return translatePMU("PKT_PMU_PUMP_2_CONFIG");
    case PKT_PMU_PUMP_DEBUG:
        return translatePMU("PKT_PMU_PUMP_DEBUG");
    case PKT_PMU_TOTAL_ENGINE_TIME:
        return translatePMU("PKT_PMU_TOTAL_ENGINE_TIME");
    case PKT_PMU_SYS_CMD:
        return translatePMU("PKT_PMU_SYS_CMD");
    case PKT_PMU_USER_DATA:
        return translatePMU("PKT_PMU_USER_DATA");
    case PKT_PMU_THROTTLE_CURVE_0:
        return translatePMU("PKT_PMU_THROTTLE_CURVE_0");
    case PKT_PMU_THROTTLE_CURVE_1:
        return translatePMU("PKT_PMU_THROTTLE_CURVE_1");
    case PKT_PMU_GPIO:
        return translatePMU("PKT_PMU_GPIO");
    case PKT_PMU_SETTINGS_DATA:
        return translatePMU("PKT_PMU_SETTINGS_DATA");
    case PKT_PMU_CHT_LOOP:
        return translatePMU("PKT_PMU_CHT_LOOP");
    }
}

/*!
 * \brief Lookup label for 'ECUSystemCommands' enum entry
 *
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char *PMUSystemCommands_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case CMD_PMU_CALIBRATE_ANALOG_CLOSED:
        return translatePMU("CMD_PMU_CALIBRATE_ANALOG_CLOSED");
    case CMD_PMU_CALIBRATE_ANALOG_OPEN:
        return translatePMU("CMD_PMU_CALIBRATE_ANALOG_OPEN");
    case CMD_PMU_CALIBRATE_PULSE_CLOSED:
        return translatePMU("CMD_PMU_CALIBRATE_PULSE_CLOSED");
    case CMD_PMU_CALIBRATE_PULSE_OPEN:
        return translatePMU("CMD_PMU_CALIBRATE_PULSE_OPEN");
    case CMD_PMU_CALIBRATE_PULSE_WRITE:
        return translatePMU("CMD_PMU_CALIBRATE_PULSE_WRITE");
    case CMD_PMU_SET_OUTPUT_DRIVER:
        return translatePMU("CMD_PMU_SET_OUTPUT_DRIVER");
    case CMD_PMU_SET_THROTTLE_CURVE_ACTIVE:
        return translatePMU("CMD_PMU_SET_THROTTLE_CURVE_ACTIVE");
    case CMD_PMU_SET_THROTTLE_CURVE_ELEMENT:
        return translatePMU("CMD_PMU_SET_THROTTLE_CURVE_ELEMENT");
    case CMD_PMU_REQUEST_THROTTLE_CURVE_DATA:
        return translatePMU("CMD_PMU_REQUEST_THROTTLE_CURVE_DATA");
    case CMD_PMU_RESET_FUEL_USED:
        return translatePMU("CMD_PMU_RESET_FUEL_USED");
    case CMD_PMU_SET_FUEL_USED_DIVISOR:
        return translatePMU("CMD_PMU_SET_FUEL_USED_DIVISOR");
    case CMD_PMU_FUEL_USED_RESET_ON_STARTUP:
        return translatePMU("CMD_PMU_FUEL_USED_RESET_ON_STARTUP");
    case CMD_PMU_SET_GOVERNOR_MODE:
        return translatePMU("CMD_PMU_SET_GOVERNOR_MODE");
    case CMD_PMU_SET_SERVO_CAN_MODE:
        return translatePMU("CMD_PMU_SET_SERVO_CAN_MODE");
    case CMD_PMU_RESET_INTO_BOOTLOADER:
        return translatePMU("CMD_PMU_RESET_INTO_BOOTLOADER");
    case CMD_PMU_RESET_DEFAULT_SETTINGS:
        return translatePMU("CMD_PMU_RESET_DEFAULT_SETTINGS");
    case CMD_PMU_SET_SERIAL_MODE:
        return translatePMU("CMD_PMU_SET_SERIAL_MODE");
    case CMD_PMU_SET_NODE_ID:
        return translatePMU("CMD_PMU_SET_NODE_ID");
    case CMD_PMU_SET_USER_DATA:
        return translatePMU("CMD_PMU_SET_USER_DATA");
    case CMD_PMU_RESET_ENGINE_TIME:
        return translatePMU("CMD_PMU_RESET_ENGINE_TIME");
    case CMD_PMU_RESET_ECU:
        return translatePMU("CMD_PMU_RESET_ECU");
    }
}

//! \return the packet data pointer from the packet
uint8_t *getPMUPacketData(void *pkt)
{
    canfd_frame *frame = (canfd_frame *) pkt;

    return (uint8_t *) frame->data;
}
//! \return the ID of a packet from the packet header
uint32_t getPMUPacketID(const void *pkt)
{
    canfd_frame *frame = (canfd_frame *) pkt;

    // Extract the message ID field from the 29-bit ID
    return (uint32_t) ((frame->can_id >> 16) & 0xFF);
}
//! \return the size of a packet from the packet header
int getPMUPacketSize(const void *pkt)
{
    canfd_frame *frame = (canfd_frame *) pkt;

    return (int) frame->len;
}
//! \return the packet data pointer from the packet, const
const uint8_t *getPMUPacketDataConst(const void *pkt)
{
    canfd_frame *frame = (canfd_frame *) pkt;

    return (const uint8_t *) frame->data;
}
//! Complete a packet after the data have been encoded
void finishPMUPacket(void *pkt, int size, uint32_t packetID)
{
    canfd_frame *frame = (canfd_frame *) pkt;

    // if (size > AP_HAL::CANFrame::MaxDataLen)
    // {
    //     size = AP_HAL::CANFrame::MaxDataLen;
    // }

    frame->len = size;

    /* Encode the CAN ID
     * 0x09mmdddd
     * - 07 = ECU_IN (to and ECU) group ID
     * - mm = Message ID
     * - dd = Device ID
     *
     * Note: The Device ID (lower 16 bits of the frame ID) will have to be inserted later
     */

    uint32_t id = (((uint8_t) PMUMessageGroup::PMU) << 24) | // CAN Group ID
                  ((packetID & 0xFF) << 16);              // Message ID

    frame->can_id = id;
}
// end of ECUProtocol.c
