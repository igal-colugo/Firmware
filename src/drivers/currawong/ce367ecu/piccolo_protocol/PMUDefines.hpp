// ECUDefines.h was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#ifndef _PMUDEFINES_H
#define _PMUDEFINES_H

// Language target is C, C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C"
{
#endif

    /*!
     * \file
     */

#include "PMUProtocol.hpp"
#include <stdbool.h>

    typedef struct
    {
        bool servoLink;          //!< 1 if CAN servo is not connected
        bool servoPosition;      //!< 1 if CAN servo is reporting a position error
        unsigned reserved_A : 6; //!< Reserved for future use
        unsigned reserved_B : 8; //!< Reserved for future use
        unsigned reserved_C : 8; //!< Reserved for future use
        unsigned reserved_D : 8; //!< Reserved for future use
    } PMU_AuxiliaryErrorBits_t;

//! return the minimum encoded length for the ECU_AuxiliaryErrorBits_t structure
#define getMinLengthOfPMU_AuxiliaryErrorBits_t() (4)

//! return the maximum encoded length for the ECU_AuxiliaryErrorBits_t structure
#define getMaxLengthOfPMU_AuxiliaryErrorBits_t() (4)

    //! Encode a ECU_AuxiliaryErrorBits_t into a byte array
    void encodePMU_AuxiliaryErrorBits_t(uint8_t *data, int *bytecount, const PMU_AuxiliaryErrorBits_t *user);

    //! Decode a ECU_AuxiliaryErrorBits_t from a byte array
    int decodePMU_AuxiliaryErrorBits_t(const uint8_t *data, int *bytecount, PMU_AuxiliaryErrorBits_t *user);

    typedef struct
    {
        unsigned knockControl : 1;              //!< Knock control error
        unsigned afCloseLoop : 1;               //!< AF closed loop error
        unsigned eepromError : 1;               //!< EEPROM error
        unsigned cmosRam : 1;                   //!< CMOS RAM error
        unsigned overVoltage : 1;               //!< Over voltage error
        unsigned powerDown : 1;                 //!< Power down error
        unsigned knockSensor : 1;               //!< Knock sensor error
        unsigned overBoost : 1;                 //!< Over boost error
        unsigned cam2Pos : 1;                   //!< CAM2 position error
        unsigned cam1Pos : 1;                   //!< CAM1 position error
        unsigned highSpeedInput2 : 1;           //!< High speed input 1 error
        unsigned highSpeedInput1 : 1;           //!< High speed input 2 error
        unsigned tooManyCylPulse : 1;           //!< Set if too many cylinder pulses
        unsigned tooFewCylPulse : 1;            //!< Set if too few cylinder pulses
        unsigned syncInputPulseMissing : 1;     //!< Set if sync input pulse missing
        unsigned cylinderInputPulseMissing : 1; //!< Set if cylinder input pulse missing
        unsigned af2Sensor : 1;                 //!< Air fuel sensor 2 error
        unsigned af1Sensor : 1;                 //!< Air fuel sensor 1 error
        unsigned baroSensor : 1;                //!< Barometric pressure sensor error
        unsigned ebpSensor : 1;                 //!< Exhaust back pressure sensor error
        unsigned mapSensor : 1;                 //!< Manifold pressure sensor error
        unsigned tpsSensor : 1;                 //!< Throttle position sensor error
        unsigned chtSensor : 1;                 //!< Cylinder head temperature sensor error
        unsigned matSensor : 1;                 //!< Manifold pressure sensor error
    } PMU_AutronicErrorBits_t;

//! return the minimum encoded length for the ECU_AutronicErrorBits_t structure
#define getMinLengthOfPMU_AutronicErrorBits_t() (4)

//! return the maximum encoded length for the ECU_AutronicErrorBits_t structure
#define getMaxLengthOfPMU_AutronicErrorBits_t() (4)

    //! Encode a ECU_AutronicErrorBits_t into a byte array
    void encodePMU_AutronicErrorBits_t(uint8_t *data, int *bytecount, const PMU_AutronicErrorBits_t *user);

    //! Decode a ECU_AutronicErrorBits_t from a byte array
    int decodePMU_AutronicErrorBits_t(const uint8_t *data, int *bytecount, PMU_AutronicErrorBits_t *user);

    typedef struct
    {
        PMU_AutronicErrorBits_t autronic;   //!< Error information for autronic processor
        PMU_AuxiliaryErrorBits_t auxiliary; //!< Error information for auxiliary processor
    } PMU_ErrorBits_t;

//! return the minimum encoded length for the ECU_ErrorBits_t structure
#define getMinLengthOfPMU_ErrorBits_t() (8)

//! return the maximum encoded length for the ECU_ErrorBits_t structure
#define getMaxLengthOfPMU_ErrorBits_t() (8)

    //! Encode a ECU_ErrorBits_t into a byte array
    void encodePMU_ErrorBits_t(uint8_t *data, int *bytecount, const PMU_ErrorBits_t *user);

    //! Decode a ECU_ErrorBits_t from a byte array
    int decodePMU_ErrorBits_t(const uint8_t *data, int *bytecount, PMU_ErrorBits_t *user);

    typedef struct
    {
        unsigned reserved : 7; //!< reserved for future use
        bool delayOnTemp;      //!< Set to base the delay on temperature, else the delay is manually set
    } PMU_ThrottleDelayConfigBits_t;

//! return the minimum encoded length for the ECU_ThrottleDelayConfigBits_t structure
#define getMinLengthOfPMU_ThrottleDelayConfigBits_t() (1)

//! return the maximum encoded length for the ECU_ThrottleDelayConfigBits_t structure
#define getMaxLengthOfPMU_ThrottleDelayConfigBits_t() (1)

    //! Encode a ECU_ThrottleDelayConfigBits_t into a byte array
    void encodePMU_ThrottleDelayConfigBits_t(uint8_t *data, int *bytecount, const PMU_ThrottleDelayConfigBits_t *user);

    //! Decode a ECU_ThrottleDelayConfigBits_t from a byte array
    int decodePMU_ThrottleDelayConfigBits_t(const uint8_t *data, int *bytecount, PMU_ThrottleDelayConfigBits_t *user);

    typedef struct
    {
        bool servoPassthrough;    //!< Enable pass-through of CAN servo data over serial link
        bool canThrottleDetected; //!< Set if the CAN throttle is detected
        bool canThrottle;         //!< Set if CAN throttle is enabled. This bit is ignored when this packet is sent to the ECU. To enable CAN throttle you must use system commands
    } PMU_ThrottleConfigBits_t;

//! return the minimum encoded length for the ECU_ThrottleConfigBits_t structure
#define getMinLengthOfPMU_ThrottleConfigBits_t() (1)

//! return the maximum encoded length for the ECU_ThrottleConfigBits_t structure
#define getMaxLengthOfPMU_ThrottleConfigBits_t() (1)

    //! Encode a ECU_ThrottleConfigBits_t into a byte array
    void encodePMU_ThrottleConfigBits_t(uint8_t *data, int *bytecount, const PMU_ThrottleConfigBits_t *user);

    //! Decode a ECU_ThrottleConfigBits_t from a byte array
    int decodePMU_ThrottleConfigBits_t(const uint8_t *data, int *bytecount, PMU_ThrottleConfigBits_t *user);

    typedef struct
    {
        bool curveActive; //!< Throttle curve is active
    } PMU_ThrottleCurveConfigBits_t;

//! return the minimum encoded length for the ECU_ThrottleCurveConfigBits_t structure
#define getMinLengthOfPMU_ThrottleCurveConfigBits_t() (1)

//! return the maximum encoded length for the ECU_ThrottleCurveConfigBits_t structure
#define getMaxLengthOfPMU_ThrottleCurveConfigBits_t() (1)

    //! Encode a ECU_ThrottleCurveConfigBits_t into a byte array
    void encodePMU_ThrottleCurveConfigBits_t(uint8_t *data, int *bytecount, const PMU_ThrottleCurveConfigBits_t *user);

    //! Decode a ECU_ThrottleCurveConfigBits_t from a byte array
    int decodePMU_ThrottleCurveConfigBits_t(const uint8_t *data, int *bytecount, PMU_ThrottleCurveConfigBits_t *user);

    typedef struct
    {
        uint16_t powerCycles;
        uint16_t customerID_deprecated; //!< Deprecated - DO NOT USE
        uint8_t versionHardware;
        uint8_t reservedA; //!< reserved for future use
        uint8_t reservedB; //!< reserved for future use
    } PMU_PMUSettings_t;

//! return the minimum encoded length for the ECU_ECUSettings_t structure
#define getMinLengthOfPMU_PMUSettings_t() (7)

//! return the maximum encoded length for the ECU_ECUSettings_t structure
#define getMaxLengthOfPMU_PMUSettings_t() (7)

    //! Encode a ECU_ECUSettings_t into a byte array
    void encodePMU_PMUSettings_t(uint8_t *data, int *bytecount, const PMU_PMUSettings_t *user);

    //! Decode a ECU_ECUSettings_t from a byte array
    int decodePMU_PMUSettings_t(const uint8_t *data, int *bytecount, PMU_PMUSettings_t *user);

    typedef struct
    {
        bool servoPassthrough; //!< If set, the ECU will pass servo CAN packet data over the serial link
        bool piccoloUplink;    //!< If set, the ECU will decode CAN messages in the PICCOLO_DATA_UP group
        bool autronicRelay;    //!< If set, the ECU supports Autronic message passthrough
        bool dualPump;         //!< If set, the ECU supports redundant fuel pump control
        bool piPump;           //!< If set, the ECU runs a PI controller for fuel pressure. If not set, it uses bang-bang control
        bool mapCorrection;    //!< If set, the ECU will automatically compensate for degredation of the MAP sensor over time
        bool watchdog;         //!< If set, the ECU watchdog timer is enabled
        bool debug;            //!< If set, the ECU is compiled with extra debug functionality enabled
    } PMU_CompileOptions_t;

//! return the minimum encoded length for the ECU_CompileOptions_t structure
#define getMinLengthOfPMU_CompileOptions_t() (2)

//! return the maximum encoded length for the ECU_CompileOptions_t structure
#define getMaxLengthOfPMU_CompileOptions_t() (2)

    //! Encode a ECU_CompileOptions_t into a byte array
    void encodePMU_CompileOptions_t(uint8_t *data, int *bytecount, const PMU_CompileOptions_t *user);

    //! Decode a ECU_CompileOptions_t from a byte array
    int decodePMU_CompileOptions_t(const uint8_t *data, int *bytecount, PMU_CompileOptions_t *user);

#ifdef __cplusplus
}
#endif
#endif // _ECUDEFINES_H
