// ECUPackets.h was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#ifndef _PMUPACKETS_H
#define _PMUPACKETS_H

// Language target is C, C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C"
{
#endif

    /*!
     * \file
     */

#include "PMUDefines.hpp"
#include "PMUProtocol.hpp"
#include "PMUSettings.hpp"
#include <stdbool.h>

    /*!
     * The throttle command packet sets the throttle position setpoint. The ECU
     * will adjust the throttle position based on this command.
     */
    typedef struct
    {
        float throttleCommand; //!< Commanded throttle position in percent
    } PMU_ThrottleCommand_t;

    //! Create the ECU_ThrottleCommand packet from parameters
    void encodePMU_ThrottleCommandPacket(void *pkt, float throttleCommand);

    //! Decode the ECU_ThrottleCommand packet to parameters
    int decodePMU_ThrottleCommandPacket(const void *pkt, float *throttleCommand);

//! return the packet ID for the ECU_ThrottleCommand packet
#define getPMU_ThrottleCommandPacketID() (PKT_PMU_THROTTLE)

//! return the minimum encoded length for the ECU_ThrottleCommand packet
#define getPMU_ThrottleCommandMinDataLength() (2)

//! return the maximum encoded length for the ECU_ThrottleCommand packet
#define getPMUThrottleCommandMaxDataLength() (2)

    /*!
     * The RPM command is used to send a target to the RPM governor on the ECU.
     * Based on this command, the ECU will use a feedback loop to maintain the
     * commanded engine speed by adjusting the throttle servo accordingly. If a
     * valid RPM command is received by the ECU, it will automatically enter RPM
     * control mode, and adjust the throttle position to match the desired RPM.
     * Sending a throttle command will cause the ECU to stop the RPM loop and enter
     * open-loop throttle control mode.
     */
    typedef struct
    {
        uint16_t rpmCmd;    //!< Engine speed command in revolutions per minute
        uint8_t rpmCmdHigh; //!< RPM command in units of 50 RPM
        uint8_t rpmCmdLow;  //!< Low part of RPM command from 0 to 49
    } PMU_RPMCommand_t;

    //! Create the ECU_RPMCommand packet
    void encodePMU_RPMCommandPacketStructure(void *pkt, const PMU_RPMCommand_t *user);

    //! Decode the ECU_RPMCommand packet
    int decodePMU_RPMCommandPacketStructure(const void *pkt, PMU_RPMCommand_t *user);

//! return the packet ID for the ECU_RPMCommand packet
#define getPMU_RPMCommandPacketID() (PKT_PMU_RPM_COMMAND)

//! return the minimum encoded length for the ECU_RPMCommand packet
#define getPMU_RPMCommandMinDataLength() (2)

//! return the maximum encoded length for the ECU_RPMCommand packet
#define getPMU_RPMCommandMaxDataLength() (2)

    /*!
     * Enumeration of auxiliary to autronic serial relay states. Autronic relay is
     * an advanced feature used to allow simultaneous connection of the Autronic
     * ECUCal software and the auxiliary processor. Autronic relay should only be
     * needed for engine development.
     */
    typedef enum
    {
        PMU_AUT_RELAY_OFF,     //!< Relay is disengaged, 19200 autronic interface rate; must use calibration switch to connect to Autronic
        PMU_AUT_RELAY_PENDING, //!< Relay enabled but not detected, 19200 autronic and external serial interface rate
        PMU_AUT_RELAY_ON       //!< Relay detected, 38400 autronic and external serial interface rate
    } PMUAutronicRelayState;

    /*!
     * The hardware config packet contains the ECU serial number and various ECU
     * configuration data. Send a zero length packet to request this data.
     */
    typedef struct
    {
        uint16_t serialNumber;            //!< ECU serial number
        uint16_t fuelDivisor;             //!< Fuel used divisior. If the divisor is greater than 100 then it is interpreted as units of 0.01 (for a higher resolution fuel calibration)
        PMUAutronicRelayState relayState; //!< Autronic relay state. This is a volatile status which will reset to AUT_RELAY_OFF on ECU power cycle.
        bool resetFuelUsedOnStart;        //!< Set if the fuel used value is reset each on each ECU power cycle
    } PMU_HardwareConfig_t;

    //! Create the ECU_HardwareConfig packet
    void encodePMUHardwareConfigPacketStructure(void *pkt, const PMU_HardwareConfig_t *user);

    //! Decode the ECU_HardwareConfig packet
    int decodePMU_HardwareConfigPacketStructure(const void *pkt, PMU_HardwareConfig_t *user);

//! return the packet ID for the ECU_HardwareConfig packet
#define getPMU_HardwareConfigPacketID() (PKT_PMU_HARDWARE_CONFIG)

//! return the minimum encoded length for the ECU_HardwareConfig packet
#define getPMU_HardwareConfigMinDataLength() (5)

//! return the maximum encoded length for the ECU_HardwareConfig packet
#define getPMU_HardwareConfigMaxDataLength() (5)

    /*!
     * The software version packet contains the auxiliary processor firmware
     * version information. Send a zero length packet to request this data.
     */
    typedef struct
    {
        bool release;              //!< 1 = Release version, 0 = Testing version
        unsigned versionMajor : 6; //!< Major version number
        uint8_t versionMinor;      //!< Minor version number
        uint8_t versionRev;        //!< Revision number
        uint8_t month;             //!< The release month from 1 (January) to 12 (December)
        uint8_t day;               //!< The release day of month from 1 to 31
        uint16_t year;             //!< The release year
        uint16_t checksum;         //!< Firmware checksum
    } PMU_Version_t;

    //! Create the ECU_Version packet
    void encodePMU_VersionPacketStructure(void *pkt, const PMU_Version_t *user);

    //! Decode the ECU_Version packet
    int decodePMU_VersionPacketStructure(const void *pkt, PMU_Version_t *user);

//! return the packet ID for the ECU_Version packet
#define getPMU_VersionPacketID() (PKT_PMU_SOFTWARE_VERSION)

//! return the minimum encoded length for the ECU_Version packet
#define getPMU_VersionMinDataLength() (8)

//! return the maximum encoded length for the ECU_Version packet
#define getPMU_VersionMaxDataLength() (8)

    /*!
     * The errors packet contains error status information for the ECU. If any
     * error bits are set, then the global error bit in the [fast
     * telemetry](#PKT_ECU_TELEMETRY_FAST) packet will also be set. Send a zero
     * length packet to request this data.
     */
    typedef struct
    {
        PMU_AutronicErrorBits_t autronicErrors;   //!< Error bits for the Autronic processor
        PMU_AuxiliaryErrorBits_t auxiliaryErrors; //!< Error bits for the auxiliary processor
    } PMU_Errors_t;

    //! Create the ECU_Errors packet
    void encodePMU_ErrorsPacketStructure(void *pkt, const PMU_Errors_t *user);

    //! Decode the ECU_Errors packet
    int decodePMU_ErrorsPacketStructure(const void *pkt, PMU_Errors_t *user);

//! return the packet ID for the ECU_Errors packet
#define getPMU_ErrorsPacketID() (PKT_PMU_ERROR_MSG)

//! return the minimum encoded length for the ECU_Errors packet
#define getPMU_ErrorsMinDataLength() (8)

//! return the maximum encoded length for the ECU_Errors packet
#define getPMU_ErrorsMaxDataLength() (8)

    /*!
     * The power cycles packet contains information on the reset condition of the
     * ECU. Send a zero length packet to request this data.
     */
    typedef struct
    {
        uint16_t powerCycles; //!< Number of power cycles
        uint8_t reserved;
        uint8_t resetCode;   //!< Auxiliary processor reset code
        uint32_t systemTime; //!< Milliseconds since system reset
    } PMU_PowerCycles_t;

    //! Create the ECU_PowerCycles packet
    void encodePMU_PowerCyclesPacketStructure(void *pkt, const PMU_PowerCycles_t *user);

    //! Decode the ECU_PowerCycles packet
    int decodePMU_PowerCyclesPacketStructure(const void *pkt, PMU_PowerCycles_t *user);

//! return the packet ID for the ECU_PowerCycles packet
#define getPMU_PowerCyclesPacketID() (PKT_PMU_POWER_CYCLES)

//! return the minimum encoded length for the ECU_PowerCycles packet
#define getPMU_PowerCyclesMinDataLength() (8)

//! return the maximum encoded length for the ECU_PowerCycles packet
#define getPMU_PowerCyclesMaxDataLength() (8)

    /*!
     * The fuel pump debug packet contains information on the pump control system.
     * Send a zero length packet to request this data.
     */
    typedef struct
    {
        float pTerm;        //!< Proportional term of the pump feedback control in percent
        float iTerm;        //!< Integral term of the pump feedback control in percent
        float dutyCycle;    //!< Pump duty cycle in percent
        float fuelPressure; //!< Fuel pressure in kilo-Pascals
    } PMU_PumpDebug_t;

    //! Create the ECU_PumpDebug packet
    void encodePMU_PumpDebugPacketStructure(void *pkt, const PMU_PumpDebug_t *user);

    //! Decode the ECU_PumpDebug packet
    int decodePMU_PumpDebugPacketStructure(const void *pkt, PMU_PumpDebug_t *user);

//! return the packet ID for the ECU_PumpDebug packet
#define getPMU_PumpDebugPacketID() (PKT_PMU_PUMP_DEBUG)

//! return the minimum encoded length for the ECU_PumpDebug packet
#define getPMU_PumpDebugMinDataLength() (8)

//! return the maximum encoded length for the ECU_PumpDebug packet
#define getPMU_PumpDebugMaxDataLength() (8)

    /*!
     * While the engine time contained in the ECU telemetry packet can be reset by
     * the user, the ECU also stores the total engine time, which cannot be reset
     * by the user. Send a zero length packet to request this data.
     */
    typedef struct
    {
        uint32_t hobbs; //!< Total engine run time in seconds
    } PMU_TotalEngineTime_t;

    //! Create the ECU_TotalEngineTime packet from parameters
    void encodePMU_TotalEngineTimePacket(void *pkt, uint32_t hobbs);

    //! Decode the ECU_TotalEngineTime packet to parameters
    int decodePMU_TotalEngineTimePacket(const void *pkt, uint32_t *hobbs);

//! return the packet ID for the ECU_TotalEngineTime packet
#define getPMU_TotalEngineTimePacketID() (PKT_PMU_TOTAL_ENGINE_TIME)

//! return the minimum encoded length for the ECU_TotalEngineTime packet
#define getPMU_TotalEngineTimeMinDataLength() (3)

//! return the maximum encoded length for the ECU_TotalEngineTime packet
#define getPMU_TotalEngineTimeMaxDataLength() (3)

    /*!
     * The eeprom settings packet contains information on the non-volatile ECU
     * settings stored in eeprom. In particular, it provides a checksum of the
     * settings data for easy comparison of settings between different ECUs. Send a
     * zero length packet to request this data.
     */
    typedef struct
    {
        uint8_t eepromVersion;               //!< Version of the EEPROM data
        uint16_t eepromSize;                 //!< Number of bytes of the EEPROM data
        uint16_t eepromChecksum;             //!< Fletcher's checksum of the EEPROM data
        PMU_CompileOptions_t compileOptions; //!< ECU compilation options
    } PMU_eepromSettings_t;

    //! Create the ECU_eepromSettings packet
    void encodePMU_eepromSettingsPacketStructure(void *pkt, const PMU_eepromSettings_t *user);

    //! Decode the ECU_eepromSettings packet
    int decodePMU_eepromSettingsPacketStructure(const void *pkt, PMU_eepromSettings_t *user);

    //! Create the ECU_eepromSettings packet from parameters
    void encodePMU_eepromSettingsPacket(void *pkt, uint8_t eepromVersion, uint16_t eepromSize, uint16_t eepromChecksum, const PMU_CompileOptions_t *compileOptions);

    //! Decode the ECU_eepromSettings packet to parameters
    int decodePMU_eepromSettingsPacket(const void *pkt, uint8_t *eepromVersion, uint16_t *eepromSize, uint16_t *eepromChecksum, PMU_CompileOptions_t *compileOptions);

//! return the packet ID for the ECU_eepromSettings packet
#define getPMU_eepromSettingsPacketID() (PKT_PMU_SETTINGS_DATA)

//! return the minimum encoded length for the ECU_eepromSettings packet
#define getPMU_eepromSettingsMinDataLength() (7)

//! return the maximum encoded length for the ECU_eepromSettings packet
#define getPMU_eepromSettingsMaxDataLength() (7)

    /*!
     * Control loop settings for the CHT control loop
     */
    typedef struct
    {
        uint8_t dTermFilter; //!< Filter value for derivative term
        bool enabled;        //!< CHT control loop enabled
        uint8_t targetTemp;  //!< Target CHT temperature
        float Kp;            //!< Proportaional gain Kp
        float Ki;            //!< Proportaional gain Ki
        float Kd;            //!< Proportaional gain Kd
    } PMU_CHTLoopSettings_t;

    //! Create the ECU_CHTLoopSettings packet
    void encodePMU_CHTLoopSettingsPacketStructure(void *pkt, const PMU_CHTLoopSettings_t *user);

    //! Decode the ECU_CHTLoopSettings packet
    int decodePMU_CHTLoopSettingsPacketStructure(const void *pkt, PMU_CHTLoopSettings_t *user);

    //! Create the ECU_CHTLoopSettings packet from parameters
    void encodePMU_CHTLoopSettingsPacket(void *pkt, uint8_t dTermFilter, bool enabled, uint8_t targetTemp, float Kp, float Ki, float Kd);

    //! Decode the ECU_CHTLoopSettings packet to parameters
    int decodePMU_CHTLoopSettingsPacket(const void *pkt, uint8_t *dTermFilter, bool *enabled, uint8_t *targetTemp, float *Kp, float *Ki, float *Kd);

//! return the packet ID for the ECU_CHTLoopSettings packet
#define getPMU_CHTLoopSettingsPacketID() (PKT_PMU_CHT_LOOP)

//! return the minimum encoded length for the ECU_CHTLoopSettings packet
#define getPMU_CHTLoopSettingsMinDataLength() (8)

//! return the maximum encoded length for the ECU_CHTLoopSettings packet
#define getPMU_CHTLoopSettingsMaxDataLength() (8)

    /*!
     * Dual pump control telemetry. Send a zero-length packet with this identifier
     * to the ECU to poll (request) this packet.
     */
    typedef struct
    {
        uint8_t mode;        //!< Current pump mode (which pump is running). Refer to the DualFuelPumpMode enumeration.
        uint8_t state;       //!< Current pump state machine state. Refer to the DualFuelPumpState enumeration.
        uint16_t stateTimer; //!< Time spent in current state
    } PMU_DualPumpControlTelemetry_t;

    //! Create the ECU_DualPumpControlTelemetry packet
    void encodePMU_DualPumpControlTelemetryPacketStructure(void *pkt, const PMU_DualPumpControlTelemetry_t *user);

    //! Decode the ECU_DualPumpControlTelemetry packet
    int decodePMU_DualPumpControlTelemetryPacketStructure(const void *pkt, PMU_DualPumpControlTelemetry_t *user);

//! return the packet ID for the ECU_DualPumpControlTelemetry packet
#define getPMU_DualPumpControlTelemetryPacketID() (0x08)

//! return the minimum encoded length for the ECU_DualPumpControlTelemetry packet
#define getPMU_DualPumpControlTelemetryMinDataLength() (4)

//! return the maximum encoded length for the ECU_DualPumpControlTelemetry packet
#define getPMU_DualPumpControlTelemetryMaxDataLength() (4)

    /*!
     * Set the telemetry period for dual-pump messages
     */
    typedef struct
    {
        uint8_t period; //!< Telemetry period (0 = Off)
    } PMU_DualPump_SetTelemetryPeriod_t;

    //! Create the ECU_DualPump_SetTelemetryPeriod packet from parameters
    void encodePMU_DualPump_SetTelemetryPeriodPacket(void *pkt, uint8_t period);

    //! Decode the ECU_DualPump_SetTelemetryPeriod packet to parameters
    int decodePMU_DualPump_SetTelemetryPeriodPacket(const void *pkt, uint8_t *period);

//! return the packet ID for the ECU_DualPump_SetTelemetryPeriod packet
#define getPMU_DualPump_SetTelemetryPeriodPacketID() (0x08)

//! return the minimum encoded length for the ECU_DualPump_SetTelemetryPeriod packet
#define getPMU_DualPump_SetTelemetryPeriodMinDataLength() (2)

//! return the maximum encoded length for the ECU_DualPump_SetTelemetryPeriod packet
#define getPMU_DualPump_SetTelemetryPeriodMaxDataLength() (2)

    /*!
     * Command to manually select a given pump mode.
     */
    typedef struct
    {
        uint8_t pump; //!< Pump selection (see DualFuelPumpMode enumeration)
    } PMU_DualPump_SelectPump_t;

    //! Create the ECU_DualPump_SelectPump packet from parameters
    void encodePMU_DualPump_SelectPumpPacket(void *pkt, uint8_t pump);

    //! Decode the ECU_DualPump_SelectPump packet to parameters
    int decodePMU_DualPump_SelectPumpPacket(const void *pkt, uint8_t *pump);

//! return the packet ID for the ECU_DualPump_SelectPump packet
#define getPMU_DualPump_SelectPumpPacketID() (0x08)

//! return the minimum encoded length for the ECU_DualPump_SelectPump packet
#define getPMU_DualPump_SelectPumpMinDataLength() (3)

//! return the maximum encoded length for the ECU_DualPump_SelectPump packet
#define getPMU_DualPump_SelectPumpMaxDataLength() (3)

    /*!
     * Command to temporarily run a particular pump in test mode. ECU will revert
     * to OTHER pump when test expires
     */
    typedef struct
    {
        uint8_t pump;    //!< Pump selection (see DualFuelPumpMode enumeration)
        uint8_t timeout; //!< Test timeout
    } PMU_DualPump_TestPump_t;

    //! Create the ECU_DualPump_TestPump packet
    void encodePMU_DualPump_TestPumpPacketStructure(void *pkt, const PMU_DualPump_TestPump_t *user);

    //! Decode the ECU_DualPump_TestPump packet
    int decodePMU_DualPump_TestPumpPacketStructure(const void *pkt, PMU_DualPump_TestPump_t *user);

//! return the packet ID for the ECU_DualPump_TestPump packet
#define getPMU_DualPump_TestPumpPacketID() (0x08)

//! return the minimum encoded length for the ECU_DualPump_TestPump packet
#define getPMU_DualPump_TestPumpMinDataLength() (3)

//! return the maximum encoded length for the ECU_DualPump_TestPump packet
#define getPMU_DualPump_TestPumpMaxDataLength() (4)

    //! Create the ECU_ThrottleCalibration packet
    void encodePMU_ThrottleCalibrationPacketStructure(void *pkt, const PMU_ThrottleSettings_t *user);

    //! Decode the ECU_ThrottleCalibration packet
    int decodePMU_ThrottleCalibrationPacketStructure(const void *pkt, PMU_ThrottleSettings_t *user);

    //! Create the ECU_ThrottleCalibration packet from parameters
    void encodePMU_ThrottleCalibrationPacket(void *pkt, uint16_t pulseClosed, uint16_t pulseOpen, const PMU_ThrottleConfigBits_t *config, uint16_t pulseInputClosed, uint16_t pulseInputOpen);

    //! Decode the ECU_ThrottleCalibration packet to parameters
    int decodePMU_ThrottleCalibrationPacket(const void *pkt, uint16_t *pulseClosed, uint16_t *pulseOpen, PMU_ThrottleConfigBits_t *config, uint16_t *pulseInputClosed,
                                            uint16_t *pulseInputOpen);

//! return the packet ID for the ECU_ThrottleCalibration packet
#define getPMU_ThrottleCalibrationPacketID() (PKT_PMU_THROTTLE_CALIBRATION)

//! return the minimum encoded length for the ECU_ThrottleCalibration packet
#define getPMU_ThrottleCalibrationMinDataLength() (8)

//! return the maximum encoded length for the ECU_ThrottleCalibration packet
#define getPMU_ThrottleCalibrationMaxDataLength() (8)

    //! Create the ECU_RPMLoopCalibration packet
    void encodePMU_RPMLoopCalibrationPacketStructure(void *pkt, const PMU_GovernorSettings_t *user);

    //! Decode the ECU_RPMLoopCalibration packet
    int decodePMU_RPMLoopCalibrationPacketStructure(const void *pkt, PMU_GovernorSettings_t *user);

//! return the packet ID for the ECU_RPMLoopCalibration packet
#define getPMU_RPMLoopCalibrationPacketID() (PKT_PMU_RPM_CALIBRATION)

//! return the minimum encoded length for the ECU_RPMLoopCalibration packet
#define getPMU_RPMLoopCalibrationMinDataLength() (8)

//! return the maximum encoded length for the ECU_RPMLoopCalibration packet
#define getPMU_RPMLoopCalibrationMaxDataLength() (8)

    //! Create the ECU_TPSDelayCalibration packet
    void encodePMU_TPSDelayCalibrationPacketStructure(void *pkt, const PMU_ThrottleSettings_t *user);

    //! Decode the ECU_TPSDelayCalibration packet
    int decodePMU_TPSDelayCalibrationPacketStructure(const void *pkt, PMU_ThrottleSettings_t *user);

    //! Create the ECU_TPSDelayCalibration packet from parameters
    void encodePMU_TPSDelayCalibrationPacket(void *pkt, uint8_t delay, const PMU_ThrottleDelayConfigBits_t *delayConfig, uint8_t maxDelay, uint8_t minDelay, uint8_t softLimit,
                                             uint8_t falloffRate, uint8_t throttleTarget, uint8_t hardLimit);

    //! Decode the ECU_TPSDelayCalibration packet to parameters
    int decodePMU_TPSDelayCalibrationPacket(const void *pkt, uint8_t *delay, PMU_ThrottleDelayConfigBits_t *delayConfig, uint8_t *maxDelay, uint8_t *minDelay, uint8_t *softLimit,
                                            uint8_t *falloffRate, uint8_t *throttleTarget, uint8_t *hardLimit);

//! return the packet ID for the ECU_TPSDelayCalibration packet
#define getPMU_TPSDelayCalibrationPacketID() (PKT_PMU_TPS_DELAY_CONFIG)

//! return the minimum encoded length for the ECU_TPSDelayCalibration packet
#define getPMU_TPSDelayCalibrationMinDataLength() (8)

//! return the maximum encoded length for the ECU_TPSDelayCalibration packet
#define getPMU_TPSDelayCalibrationMaxDataLength() (8)

    /*!
     * The telmetry settings packet is used to configure the telemetry data rates
     * for the ECU. The ECU will echo the packet as confirmation of its receipt.
     * Send a zero length packet to request the current settings.
     */
    typedef struct
    {
        uint8_t fastTelemetryPeriod; //!< Time between fast telemetry packets in 50ms increments
        uint8_t slowTelemetryPeriod; //!< Time between slow telemetry packets in 500ms increments
        uint8_t silencePeriod;       //!< Seconds of time the ECU waits after bootup before sending telemetry.
    } PMU_TelemetrySettings_t;

    //! Create the ECU_TelemetrySettings packet
    void encodePMU_TelemetrySettingsPacketStructure(void *pkt, const PMU_TelemetrySettings_t *user);

    //! Decode the ECU_TelemetrySettings packet
    int decodePMU_TelemetrySettingsPacketStructure(const void *pkt, PMU_TelemetrySettings_t *user);

//! return the packet ID for the ECU_TelemetrySettings packet
#define getPMU_TelemetrySettingsPacketID() (PKT_PMU_TELEMETRY_SETTINGS)

//! return the minimum encoded length for the ECU_TelemetrySettings packet
#define getPMU_TelemetrySettingsMinDataLength() (3)

//! return the maximum encoded length for the ECU_TelemetrySettings packet
#define getPMU_TelemetrySettingsMaxDataLength() (3)

    //! Create the ECU_PumpConfig packet
    void encodePMU_PumpConfigPacketStructure(void *pkt, const PMU_PumpSettings_t *user);

    //! Decode the ECU_PumpConfig packet
    int decodePMU_PumpConfigPacketStructure(const void *pkt, PMU_PumpSettings_t *user);

//! return the packet ID for the ECU_PumpConfig packet
#define getPMU_PumpConfigPacketID() (PKT_PMU_PUMP_CONFIG)

//! return the minimum encoded length for the ECU_PumpConfig packet
#define getPMU_PumpConfigMinDataLength() (8)

//! return the maximum encoded length for the ECU_PumpConfig packet
#define getPMU_PumpConfigMaxDataLength() (8)

    //! Create the ECU_Pump2Config packet
    void encodePMU_Pump2ConfigPacketStructure(void *pkt, const PMU_PumpSettings_t *user);

    //! Decode the ECU_Pump2Config packet
    int decodePMU_Pump2ConfigPacketStructure(const void *pkt, PMU_PumpSettings_t *user);

//! return the packet ID for the ECU_Pump2Config packet
#define getPMU_Pump2ConfigPacketID() (PKT_PMU_PUMP_2_CONFIG)

//! return the minimum encoded length for the ECU_Pump2Config packet
#define getPMU_Pump2ConfigMinDataLength() (7)

//! return the maximum encoded length for the ECU_Pump2Config packet
#define getPMU_Pump2ConfigMaxDataLength() (7)

    /*!
     * The user data packet provides the user with 8 (eight) bytes of data for
     * storing custom parameters or settings in ECU EEPROM (non-volatile) memory.
     * The ECU does not make use of these values; they are simply for storing user
     * data. Send a zero length packet to request the current settings. To set
     * these values send the system command SET_USER_DATA. Data values must be set
     * individually.
     */
    typedef struct
    {
        uint8_t userData[8]; //!< 8 bytes of user data
    } PMU_UserData_t;

    //! Create the ECU_UserData packet from parameters
    void encodePMU_UserDataPacket(void *pkt, const uint8_t userData[8]);

    //! Decode the ECU_UserData packet to parameters
    int decodePMU_UserDataPacket(const void *pkt, uint8_t userData[8]);

//! return the packet ID for the ECU_UserData packet
#define getPMU_UserDataPacketID() (PKT_PMU_USER_DATA)

//! return the minimum encoded length for the ECU_UserData packet
#define getPMU_UserDataMinDataLength() (8)

//! return the maximum encoded length for the ECU_UserData packet
#define getPMU_UserDataMaxDataLength() (8)

    /*!
     * First throttle curve packet, which contains the lower 6 term of the throttle
     * linearization table. To request the throttle curve data (both packets), send
     * the system command REQUEST_THROTTLE_CURVE_DATA. To change the throttle curve
     * data send the system command SET_THROTTLE_CURVE_ELEMENT.
     */
    typedef struct
    {
        float throttleCurve[6]; //!< Throttle output values for the lower 6 cells in the throttle lookup table
    } PMU_ThrottleCurve_t;

    //! Create the ECU_ThrottleCurve packet from parameters
    void encodePMU_ThrottleCurvePacket(void *pkt, const float throttleCurve[6]);

    //! Decode the ECU_ThrottleCurve packet to parameters
    int decodePMU_ThrottleCurvePacket(const void *pkt, float throttleCurve[6]);

//! return the packet ID for the ECU_ThrottleCurve packet
#define getPMU_ThrottleCurvePacketID() (PKT_PMU_THROTTLE_CURVE_0)

//! return the minimum encoded length for the ECU_ThrottleCurve packet
#define getPMU_ThrottleCurveMinDataLength() (6)

//! return the maximum encoded length for the ECU_ThrottleCurve packet
#define getPMU_ThrottleCurveMaxDataLength() (6)

    //! Create the ECU_ThrottleCurve1 packet from parameters
    void encodePMU_ThrottleCurve1Packet(void *pkt, const float throttleCurve[5]);

    //! Decode the ECU_ThrottleCurve1 packet to parameters
    int decodePMU_ThrottleCurve1Packet(const void *pkt, float throttleCurve[5]);

//! return the packet ID for the ECU_ThrottleCurve1 packet
#define getPMU_ThrottleCurve1PacketID() (PKT_PMU_THROTTLE_CURVE_1)

//! return the minimum encoded length for the ECU_ThrottleCurve1 packet
#define getPMU_ThrottleCurve1MinDataLength() (5)

//! return the maximum encoded length for the ECU_ThrottleCurve1 packet
#define getPMU_ThrottleCurve1MaxDataLength() (5)

    /*!
     * The system command packets follow the format provided below. Refer further
     * in the document for complete documentation on each system command packet.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration
        uint8_t parambytes[3]; //!< Up to 3 parameter bytes for a system command
    } PMU_SystemCommand_t;

    //! Create the ECU_SystemCommand packet
    void encodePMU_SystemCommandPacketStructure(void *pkt, const PMU_SystemCommand_t *user);

    //! Decode the ECU_SystemCommand packet
    int decodePMU_SystemCommandPacketStructure(const void *pkt, PMU_SystemCommand_t *user);

//! return the packet ID for the ECU_SystemCommand packet
#define getPMU_SystemCommandPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_SystemCommand packet
#define getPMU_SystemCommandMinDataLength() (1)

//! return the maximum encoded length for the ECU_SystemCommand packet
#define getPMU_SystemCommandMaxDataLength() (4)

    /*!
     * Save the current value of the analog throttle position input as the 'Closed'
     * position. To calibrate the closed analog input position, set the desired
     * analog input level, and send this command to the ECU.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
    } PMU_CalibrateAnalogClosed_t;

    //! Create the ECU_CalibrateAnalogClosed packet from parameters
    void encodePMU_CalibrateAnalogClosedPacket(void *pkt);

    //! Decode the ECU_CalibrateAnalogClosed packet to parameters
    int decodePMU_CalibrateAnalogClosedPacket(const void *pkt, PMUSystemCommands *cmd);

//! return the packet ID for the ECU_CalibrateAnalogClosed packet
#define getPMU_CalibrateAnalogClosedPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_CalibrateAnalogClosed packet
#define getPMU_CalibrateAnalogClosedMinDataLength() (1)

//! return the maximum encoded length for the ECU_CalibrateAnalogClosed packet
#define getPMU_CalibrateAnalogClosedMaxDataLength() (1)

    /*!
     * Save the current value of the analog throttle position input as the 'Open'
     * position. To calibrate the open analog input position, set the desired
     * analog input level, and send this command to the ECU.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
    } PMU_CalibrateAnalogOpen_t;

    //! Create the ECU_CalibrateAnalogOpen packet from parameters
    void encodePMU_CalibrateAnalogOpenPacket(void *pkt);

    //! Decode the ECU_CalibrateAnalogOpen packet to parameters
    int decodePMU_CalibrateAnalogOpenPacket(const void *pkt, PMUSystemCommands *cmd);

//! return the packet ID for the ECU_CalibrateAnalogOpen packet
#define getPMU_CalibrateAnalogOpenPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_CalibrateAnalogOpen packet
#define getPMU_CalibrateAnalogOpenMinDataLength() (1)

//! return the maximum encoded length for the ECU_CalibrateAnalogOpen packet
#define getPMU_CalibrateAnalogOpenMaxDataLength() (1)

    /*!
     * Save the current value of the throttle output pulse width to a temporary
     * variable in the ECU. When the CALIBRATE_PULSE_WRITE command is sent to the
     * ECU, this value will be saved as the 'Closed' pulse width.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
    } PMU_CalibratePulseClosed_t;

    //! Create the ECU_CalibratePulseClosed packet from parameters
    void encodePMU_CalibratePulseClosedPacket(void *pkt);

    //! Decode the ECU_CalibratePulseClosed packet to parameters
    int decodePMU_CalibratePulseClosedPacket(const void *pkt, PMUSystemCommands *cmd);

//! return the packet ID for the ECU_CalibratePulseClosed packet
#define getPMU_CalibratePulseClosedPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_CalibratePulseClosed packet
#define getPMU_CalibratePulseClosedMinDataLength() (1)

//! return the maximum encoded length for the ECU_CalibratePulseClosed packet
#define getPMU_CalibratePulseClosedMaxDataLength() (1)

    /*!
     * Save the current value of the throttle output pulse width to a temporary
     * variable in the ECU. When the CALIBRATE_PULSE_WRITE command is sent to the
     * ECU, this value will be saved as the 'Open' pulse width.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
    } PMU_CalibratePulseOpen_t;

    //! Create the ECU_CalibratePulseOpen packet from parameters
    void encodePMU_CalibratePulseOpenPacket(void *pkt);

    //! Decode the ECU_CalibratePulseOpen packet to parameters
    int decodePMU_CalibratePulseOpenPacket(const void *pkt, PMUSystemCommands *cmd);

//! return the packet ID for the ECU_CalibratePulseOpen packet
#define getPMU_CalibratePulseOpenPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_CalibratePulseOpen packet
#define getPMU_CalibratePulseOpenMinDataLength() (1)

//! return the maximum encoded length for the ECU_CalibratePulseOpen packet
#define getPMU_CalibratePulseOpenMaxDataLength() (1)

    /*!
     * Configure the throttle output positions. The CALIBRATE_PULSE_CLOSED and
     * CALIBRATE_PULSE_OPEN commands should have already been sent to the ECU. The
     * ECU then saves the temporary values as the 'Closed' and 'Open' throttle
     * output values, respectively.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
    } PMU_CalibratePulseWrite_t;

    //! Create the ECU_CalibratePulseWrite packet from parameters
    void encodePMU_CalibratePulseWritePacket(void *pkt);

    //! Decode the ECU_CalibratePulseWrite packet to parameters
    int decodePMU_CalibratePulseWritePacket(const void *pkt, PMUSystemCommands *cmd);

//! return the packet ID for the ECU_CalibratePulseWrite packet
#define getPMU_CalibratePulseWritePacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_CalibratePulseWrite packet
#define getPMU_CalibratePulseWriteMinDataLength() (1)

//! return the maximum encoded length for the ECU_CalibratePulseWrite packet
#define getPMU_CalibratePulseWriteMaxDataLength() (1)

    /*!
     * Set one of four high-current output drivers.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
        uint8_t driver;        //!< Select driver number (1, 2, 3 or 4)
        uint8_t status;        //!< Set driver status (1 = ON, 0 = OFF)
    } PMU_SetOutputDriver_t;

    //! Create the ECU_SetOutputDriver packet from parameters
    void encodePMUSetOutputDriverPacket(void *pkt, uint8_t driver, uint8_t status);

    //! Decode the ECU_SetOutputDriver packet to parameters
    int decodePMU_SetOutputDriverPacket(const void *pkt, PMUSystemCommands *cmd, uint8_t *driver, uint8_t *status);

//! return the packet ID for the ECU_SetOutputDriver packet
#define getPMU_SetOutputDriverPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetOutputDriver packet
#define getPMU_SetOutputDriverMinDataLength() (3)

//! return the maximum encoded length for the ECU_SetOutputDriver packet
#define getPMU_SetOutputDriverMaxDataLength() (3)

    /*!
     * Turn the throttle linearization curve either on or off.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
        uint8_t active;        //!< Curve active (1 = ON, 0 = OFF)
    } PMU_SetThrottleCurveActive_t;

    //! Create the ECU_SetThrottleCurveActive packet from parameters
    void encodePMU_SetThrottleCurveActivePacket(void *pkt, uint8_t active);

    //! Decode the ECU_SetThrottleCurveActive packet to parameters
    int decodePMU_SetThrottleCurveActivePacket(const void *pkt, PMUSystemCommands *cmd, uint8_t *active);

//! return the packet ID for the ECU_SetThrottleCurveActive packet
#define getPMU_SetThrottleCurveActivePacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetThrottleCurveActive packet
#define getPMU_SetThrottleCurveActiveMinDataLength() (2)

//! return the maximum encoded length for the ECU_SetThrottleCurveActive packet
#define getPMU_SetThrottleCurveActiveMaxDataLength() (2)

    /*!
     * Set individual elements in the throttle linearization lookup table.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
        uint8_t index;         //!< Index into the throttle curve table from 0 to 10 (0% to 100%) throttle input
        float throttleOutput;  //!< Percentage throttle output for this curve element
    } PMU_SetThrottleCurveElement_t;

    //! Create the ECU_SetThrottleCurveElement packet from parameters
    void encodePMU_SetThrottleCurveElementPacket(void *pkt, uint8_t index, float throttleOutput);

    //! Decode the ECU_SetThrottleCurveElement packet to parameters
    int decodePMUSetThrottleCurveElementPacket(const void *pkt, PMUSystemCommands *cmd, uint8_t *index, float *throttleOutput);

//! return the packet ID for the ECU_SetThrottleCurveElement packet
#define getPMU_SetThrottleCurveElementPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetThrottleCurveElement packet
#define getPMU_SetThrottleCurveElementMinDataLength() (3)

//! return the maximum encoded length for the ECU_SetThrottleCurveElement packet
#define getPMU_SetThrottleCurveElementMaxDataLength() (3)

    /*!
     * Request the throttle curve lookup table data. If requested on CAN, the data
     * will be returned on CAN. If requested on RS232, the data will be returned on
     * RS232.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
    } PMU_RequestThrottleCurveData_t;

    //! Create the ECU_RequestThrottleCurveData packet from parameters
    void encodePMU_RequestThrottleCurveDataPacket(void *pkt);

    //! Decode the ECU_RequestThrottleCurveData packet to parameters
    int decodePMU_RequestThrottleCurveDataPacket(const void *pkt, PMUSystemCommands *cmd);

//! return the packet ID for the ECU_RequestThrottleCurveData packet
#define getPMU_RequestThrottleCurveDataPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_RequestThrottleCurveData packet
#define getPMU_RequestThrottleCurveDataMinDataLength() (1)

//! return the maximum encoded length for the ECU_RequestThrottleCurveData packet
#define getPMU_RequestThrottleCurveDataMaxDataLength() (1)

    /*!
     * Reset the FuelUsed value. This will set the FuelUsed data to zero.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
    } PMU_ResetFuelUsed_t;

    //! Create the ECU_ResetFuelUsed packet from parameters
    void encodePMU_ResetFuelUsedPacket(void *pkt);

    //! Decode the ECU_ResetFuelUsed packet to parameters
    int decodePMU_ResetFuelUsedPacket(const void *pkt, PMUSystemCommands *cmd);

//! return the packet ID for the ECU_ResetFuelUsed packet
#define getPMU_ResetFuelUsedPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_ResetFuelUsed packet
#define getPMU_ResetFuelUsedMinDataLength() (1)

//! return the maximum encoded length for the ECU_ResetFuelUsed packet
#define getPMU_ResetFuelUsedMaxDataLength() (1)

    /*!
     * Set the fuel used divisor
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
        uint16_t
            divisor; //!< The fuel used divisor. The fuel used value is divided by this divisor before being transmitted by the auxiliary processor. Set this value to 1 to leave the fuel
                     //!< used data unaffected. If you use values greater than 100 the divisor is automatically interpreted as being in units of 0.01 (i.e. 100 times the resolution).
    } PMU_SetFuelUsedDivisor_t;

    //! Create the ECU_SetFuelUsedDivisor packet from parameters
    void encodePMU_SetFuelUsedDivisorPacket(void *pkt, uint16_t divisor);

    //! Decode the ECU_SetFuelUsedDivisor packet to parameters
    int decodePMU_SetFuelUsedDivisorPacket(const void *pkt, PMUSystemCommands *cmd, uint16_t *divisor);

//! return the packet ID for the ECU_SetFuelUsedDivisor packet
#define getPMU_SetFuelUsedDivisorPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetFuelUsedDivisor packet
#define getPMU_SetFuelUsedDivisorMinDataLength() (3)

//! return the maximum encoded length for the ECU_SetFuelUsedDivisor packet
#define getPMU_SetFuelUsedDivisorMaxDataLength() (3)

    /*!
     * Set or clear the Fuel Used reset flag. If this flag is set, the FuelUsed
     * data will reset (to zero) when the ECU is power cycled.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
        uint8_t reset;         //!< 1 = Reset Fuel Used data on powerup 0 = Do not reset Fuel Used data on power up
    } PMU_SetFuelUsedResetFlag_t;

    //! Create the ECU_SetFuelUsedResetFlag packet from parameters
    void encodePMU_SetFuelUsedResetFlagPacket(void *pkt, uint8_t reset);

    //! Decode the ECU_SetFuelUsedResetFlag packet to parameters
    int decodePMU_SetFuelUsedResetFlagPacket(const void *pkt, PMUSystemCommands *cmd, uint8_t *reset);

//! return the packet ID for the ECU_SetFuelUsedResetFlag packet
#define getPMU_SetFuelUsedResetFlagPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetFuelUsedResetFlag packet
#define getPMU_SetFuelUsedResetFlagMinDataLength() (2)

//! return the maximum encoded length for the ECU_SetFuelUsedResetFlag packet
#define getPMU_SetFuelUsedResetFlagMaxDataLength() (2)

    /*!
     * Set the serial mode used for Autronic relay. When Autronic relay is enabled
     * the external serial port of the ECU is reconfigured to connect to ECUCal,
     * relaying bytes to the internal autronic processor; while still allowing the
     * auxiliary processor to see telemetry from Autronic. This is fundamentally
     * different from using the switch to calibration mode, which bypasses the
     * auxiliary processor altogether, cutting it off from autronic telemetry.
     */
    typedef struct
    {
        PMUSystemCommands cmd;      //!< The command enumeration. Field is encoded constant.
        PMUAutronicRelayState mode; //!< The serial relay mode to command
    } PMU_SetSerialMode_t;

    //! Create the ECU_SetSerialMode packet from parameters
    void encodePMU_SetSerialModePacket(void *pkt, PMUAutronicRelayState mode);

    //! Decode the ECU_SetSerialMode packet to parameters
    int decodePMU_SetSerialModePacket(const void *pkt, PMUSystemCommands *cmd, PMUAutronicRelayState *mode);

//! return the packet ID for the ECU_SetSerialMode packet
#define getPMU_SetSerialModePacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetSerialMode packet
#define getPMU_SetSerialModeMinDataLength() (2)

//! return the maximum encoded length for the ECU_SetSerialMode packet
#define getPMU_SetSerialModeMaxDataLength() (2)

    /*!
     * Set a custom address value for the ECU.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
        uint16_t address;      //!< ECU address in the range {1, 65534}
    } PMU_SetECUAddress_t;

    //! Create the ECU_SetECUAddress packet from parameters
    void encodePMU_SetECUAddressPacket(void *pkt, uint16_t address);

    //! Decode the ECU_SetECUAddress packet to parameters
    int decodePMU_SetPMUAddressPacket(const void *pkt, PMUSystemCommands *cmd, uint16_t *address);

//! return the packet ID for the ECU_SetECUAddress packet
#define getPMU_SetPMUAddressPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetECUAddress packet
#define getPMU_SetPMUAddressMinDataLength() (3)

//! return the maximum encoded length for the ECU_SetECUAddress packet
#define getPMU_SetPMUAddressMaxDataLength() (3)

    /*!
     * Save a single byte of USER_DATA in EEPROM.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
        uint8_t index;         //!< USER_DATA address (0 to 7)
        uint8_t userdata;      //!< USER_DATA variable
    } PMU_SetUserData_t;

    //! Create the ECU_SetUserData packet from parameters
    void encodePMU_SetUserDataPacket(void *pkt, uint8_t index, uint8_t userdata);

    //! Decode the ECU_SetUserData packet to parameters
    int decodePMU_SetUserDataPacket(const void *pkt, PMUSystemCommands *cmd, uint8_t *index, uint8_t *userdata);

//! return the packet ID for the ECU_SetUserData packet
#define getPMU_SetUserDataPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_SetUserData packet
#define getPMU_SetUserDataMinDataLength() (3)

//! return the maximum encoded length for the ECU_SetUserData packet
#define getPMU_SetUserDataMaxDataLength() (3)

    /*!
     * Reset the engine runtime.
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
        uint32_t time;         //!< The new value of the engine time counter in seconds
    } PMU_ResetEngineTime_t;

    //! Create the ECU_ResetEngineTime packet from parameters
    void encodePMU_ResetEngineTimePacket(void *pkt, uint32_t time);

    //! Decode the ECU_ResetEngineTime packet to parameters
    int decodePMU_ResetEngineTimePacket(const void *pkt, PMUSystemCommands *cmd, uint32_t *time);

//! return the packet ID for the ECU_ResetEngineTime packet
#define getPMU_ResetEngineTimePacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_ResetEngineTime packet
#define getPMU_ResetEngineTimeMinDataLength() (1)

//! return the maximum encoded length for the ECU_ResetEngineTime packet
#define getPMU_ResetEngineTimeMaxDataLength() (4)

    /*!
     * Reset the ECU
     */
    typedef struct
    {
        PMUSystemCommands cmd; //!< The command enumeration. Field is encoded constant.
    } PMU_ResetECU_t;

    //! Create the ECU_ResetECU packet from parameters
    void encodePMU_ResetPMUPacket(void *pkt);

    //! Decode the ECU_ResetECU packet to parameters
    int decodePMU_ResetPMUPacket(const void *pkt, PMUSystemCommands *cmd);

//! return the packet ID for the ECU_ResetECU packet
#define getPMU_ResetPMUPacketID() (PKT_PMU_SYS_CMD)

//! return the minimum encoded length for the ECU_ResetECU packet
#define getPMU_ResetPMUMinDataLength() (4)

//! return the maximum encoded length for the ECU_ResetECU packet
#define getPMU_ResetPMUMaxDataLength() (4)

#pragma region  Currawong PMU packets
    /*!
     * Fast telemetry contains high priority telemetry data and is transmitted at a
     * user configurable period between 50ms (20Hz) and 10s. By default, the fast
     * telemetry message is transmitted at 10Hz (every 100ms)
     */
    typedef struct
    {
        uint8_t avionics_output_voltage; //!< An unsigned byte with value 10 times the measured voltage (i.e. in 0.1V increments).Value ranges from 0 to 250 (0.0 to 25.0V).
        uint8_t vdc_28_output_voltage;   //!< An unsigned byte with value 5 times the measured voltage(i.e.in 0.2V increments).Value ranges from 0 to 250 (0.0 to 50.0V).
        uint8_t payload_output_voltage;  //!< An unsigned byte with value 10 times the measured voltage (i.e. in 0.1V increments).Value ranges from 0 to 250 (0.0 to 25.0V).
        uint8_t servo_output_voltage;    //!< An unsigned byte with value 10 times the measured voltage (i.e. in 0.1V increments).Value ranges from 0 to 125 (0.0 to 12.5V).
        uint8_t battery_A_voltage;       //!< An unsigned byte with value 10 times the measured voltage (i.e. in 0.1V increments).Value ranges from 0 to 250 (0.0 to 25.0V).
        uint8_t battery_B_voltage;       //!< An unsigned byte with value 10 times the measured voltage (i.e. in 0.1V increments).Value ranges from 0 to 250 (0.0 to 25.0V).
        uint8_t generator_voltage;       //!< An unsigned byte with value 2.5 times the measured voltage (i.e. in 0.4V increments).Value ranges from 0 to 250 (0.0 to 100.0V).
    } PMU_Voltages_t;

    //! Create the ECU_TelemetryFast packet
    void encodePMU_VoltagesPacketStructure(void *pkt, const PMU_Voltages_t *user);

    //! Decode the ECU_TelemetryFast packet
    int decodePMU_VoltagesPacketStructure(const void *pkt, PMU_Voltages_t *user);

//! return the packet ID for the ECU_TelemetryFast packet
#define getPMU_VoltagesPacketID() (PKT_PMU_VOLTAGES)

//! return the minimum encoded length for the ECU_TelemetryFast packet
#define getPMU_VoltagesMinDataLength() (7)

//! return the maximum encoded length for the ECU_TelemetryFast packet
#define getPMU_VoltagesMaxDataLength() (7)

    /*!
     * Fast telemetry contains high priority telemetry data and is transmitted at a
     * user configurable period between 50ms (20Hz) and 10s. By default, the fast
     * telemetry message is transmitted at 10Hz (every 100ms)
     */
    typedef struct
    {
        uint8_t avionics_output_current; //!< An unsigned byte with value 10 times the measured current (i.e. in 0.1A increments).Value ranges from 0 to 100 (0.0 to 10.0A).
        uint8_t vdc_28_output_current;   //!< A signed byte with value 10 times the measured current (i.e. in 0.1A increments).Value ranges from -125 to +125 (-12.5 to +12.5A).
        uint8_t payload_output_current;  //!< An unsigned byte with value 10 times the measured current (i.e. in 0.1A increments).Value ranges from 0 to 100 (0.0 to 10.0A).
        uint8_t servo_output_current;    //!< An unsigned byte with value 10 times the measured current (i.e. in 0.1A increments).Value ranges from 0 to 100 (0.0 to 10.0A).
        uint8_t battery_A_current;       //!< A signed byte with value 10 times the measured current (i.e. in 0.1A increments).Value ranges from –125 to +125 (-12.5 to +12.5A).
        uint8_t battery_B_current;       //!< A signed byte with value 10 times the measured current (i.e. in 0.1A increments).Value ranges from –125 to +125 (-12.5 to +12.5A).
    } PMU_Currents_t;

    //! Create the ECU_TelemetryFast packet
    void encodePMU_CurrentsPacketStructure(void *pkt, const PMU_Currents_t *user);

    //! Decode the ECU_TelemetryFast packet
    int decodePMU_CurrentsPacketStructure(const void *pkt, PMU_Currents_t *user);

//! return the packet ID for the ECU_TelemetryFast packet
#define getPMU_CurrentsPacketID() (PKT_PMU_CURRENTS)

//! return the minimum encoded length for the ECU_TelemetryFast packet
#define getPMU_CurrentsMinDataLength() (6)

//! return the maximum encoded length for the ECU_TelemetryFast packet
#define getPMU_CurrentsMaxDataLength() (6)

    /*!
     * Fast telemetry contains high priority telemetry data and is transmitted at a
     * user configurable period between 50ms (20Hz) and 10s. By default, the fast
     * telemetry message is transmitted at 10Hz (every 100ms)
     */
    typedef struct
    {
        int16_t battery_A_energy; //!< A signed integer with value equal to the time-integral of current into battery A since power up in mAH.Value ranges from –32768 to +32767.
        int16_t battery_B_energy; //!< A signed integer with value equal to the time-integral of current into battery B since power - up in mAH.Value ranges from –32768 to + 32767.
    } PMU_BatteryStatuses_t;

    //! Create the ECU_TelemetryFast packet
    void encodePMU_BatteryStatusesPacketStructure(void *pkt, const PMU_BatteryStatuses_t *user);

    //! Decode the ECU_TelemetryFast packet
    int decodePMU_BatteryStatusesPacketStructure(const void *pkt, PMU_BatteryStatuses_t *user);

//! return the packet ID for the ECU_TelemetryFast packet
#define getPMU_BatteryStatusesPacketID() (PKT_PMU_BATTERY_STATUSES)

//! return the minimum encoded length for the ECU_TelemetryFast packet
#define getPMU_BatteryStatusesMinDataLength() (4)

//! return the maximum encoded length for the ECU_TelemetryFast packet
#define getPMU_BatteryStatusesMaxDataLength() (4)

    /*!
     * Fast telemetry contains high priority telemetry data and is transmitted at a
     * user configurable period between 50ms (20Hz) and 10s. By default, the fast
     * telemetry message is transmitted at 10Hz (every 100ms)
     */
    typedef struct
    {
        int8_t internal_PMU_temperature; //!< A signed byte with value equal to the temperature inside the PMU in degrees Celsius.Value ranges from –128 to +127.
        int8_t battery_A_temperature;    //!< A signed byte with value equal to the temperature of battery A in degrees Celsius.Value ranges from –128 to +127(–128 = no sensor).
        int8_t battery_B_temperature;    //!< A signed byte with value equal to the temperature of battery B in degrees Celsius.Value ranges from - 128 to +127(–128 = no sensor).
        int8_t
            generator_temperature; //!< A signed byte with value equal to the temperature of the generator(BLDC motor) in degrees Celsius.Value ranges from - 128 to +127(–128 = no sensor).
        int8_t engine_starter_module_temperature; //!< A signed byte with value equal to the temperature of the engine starter module in degrees Celsius.Value ranges from - 49 to + 127.
    } PMU_Temperatures_t;

    //! Create the ECU_TelemetryFast packet
    void encodePMU_TemperaturesPacketStructure(void *pkt, const PMU_Temperatures_t *user);

    //! Decode the ECU_TelemetryFast packet
    int decodePMU_TemperaturesPacketStructure(const void *pkt, PMU_Temperatures_t *user);

//! return the packet ID for the ECU_TelemetryFast packet
#define getPMU_TemperaturesPacketID() (PKT_PMU_TEMPERATURES)

//! return the minimum encoded length for the ECU_TelemetryFast packet
#define getPMU_TemperaturesMinDataLength() (5)

//! return the maximum encoded length for the ECU_TelemetryFast packet
#define getPMU_TemperaturesMaxDataLength() (5)

    /*!
     * Fast telemetry contains high priority telemetry data and is transmitted at a
     * user configurable period between 50ms (20Hz) and 10s. By default, the fast
     * telemetry message is transmitted at 10Hz (every 100ms)
     */
    typedef struct
    {
        uint16_t generator_speed; //!< An unsigned integer with value equal to the generator speed in RPM.Value ranges from 0 to 65535.
        uint8_t flag_register_0;  //!<
        uint8_t flag_register_1;  //!<
        uint8_t flag_register_2;  //!<
    } PMU_Miscellaneous_t;

    //! Create the ECU_TelemetryFast packet
    void encodePMU_MiscellaneousPacketStructure(void *pkt, const PMU_Miscellaneous_t *user);

    //! Decode the ECU_TelemetryFast packet
    int decodePMU_MiscellaneousPacketStructure(const void *pkt, PMU_Miscellaneous_t *user);

//! return the packet ID for the ECU_TelemetryFast packet
#define getPMU_MiscellaneousPacketID() (PKT_PMU_MISCELLANEOUS)

//! return the minimum encoded length for the ECU_TelemetryFast packet
#define getPMU_MiscellaneousMinDataLength() (5)

//! return the maximum encoded length for the ECU_TelemetryFast packet
#define getPMU_MiscellaneousMaxDataLength() (5)

#pragma endregion Currawong packets

#ifdef __cplusplus
}
#endif
#endif // _ECUPACKETS_H
